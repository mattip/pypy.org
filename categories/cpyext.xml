<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts about cpyext)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/categories/cpyext.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Tue, 09 Mar 2021 08:48:53 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Leysin 2020 Sprint Report</title><link>https://www.pypy.org/posts/2020/03/leysin-2020-sprint-report-764567777353955897.html</link><dc:creator>The PyPy Team</dc:creator><description>&lt;p&gt;At the end of February ten of us gathered in Leysin, Switzerland to work on&lt;br&gt;
a variety of topics including &lt;a class="reference external" href="https://github.com/pyhandle/hpy/"&gt;HPy&lt;/a&gt;, &lt;a class="reference external" href="https://buildbot.pypy.org/summary?branch=py3.7"&gt;PyPy Python 3.7&lt;/a&gt; support and the PyPy&lt;br&gt;
migration to &lt;a class="reference external" href="https://foss.heptapod.net/pypy/"&gt;Heptapod&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;
&lt;/p&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;
&lt;a href="https://1.bp.blogspot.com/-PIs_hVhn3RY/XnFDceuihNI/AAAAAAAAbRg/LKMOMWxeFw4jhcwqy8jx7iKzKE01fbfxQCEwYBhgL/s1600/2020_leysin_sprint_attendees.jpg" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="180" src="https://1.bp.blogspot.com/-PIs_hVhn3RY/XnFDceuihNI/AAAAAAAAbRg/LKMOMWxeFw4jhcwqy8jx7iKzKE01fbfxQCEwYBhgL/s320/2020_leysin_sprint_attendees.jpg" width="320"&gt;&lt;/a&gt;&lt;/div&gt;
&lt;br&gt;
We had a fun and productive week. The snow was beautiful. There was skiing&lt;br&gt;
and lunch at the top of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Berneuse"&gt;Berneuse&lt;/a&gt;, cooking together, some late nights at&lt;br&gt;
the pub next door, some even later nights coding, and of course the&lt;br&gt;
obligatory cheese fondue outing.&lt;br&gt;
&lt;br&gt;
There were a few of us participating in a PyPy sprint for the first time&lt;br&gt;
and a few familiar faces who had attended many sprints. Many different&lt;br&gt;
projects were represented including PyPy, &lt;a class="reference external" href="https://github.com/pyhandle/hpy/"&gt;HPy&lt;/a&gt;, &lt;a class="reference external" href="https://github.com/graalvm/graalpython"&gt;GraalPython&lt;/a&gt;,&lt;br&gt;
&lt;a class="reference external" href="https://foss.heptapod.net/pypy/"&gt;Heptapod&lt;/a&gt;, and &lt;a class="reference external" href="https://github.com/dgrunwald/rust-cpython"&gt;rust-cpython&lt;/a&gt;. The atmosphere was relaxed and welcoming, so if&lt;br&gt;
you're thinking of attending the next one -- please do!&lt;br&gt;
&lt;br&gt;
Topics worked on:&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;
HPy&lt;/h2&gt;
HPy is a new project to design and implement a better API for extending&lt;br&gt;
Python in C. If you're unfamiliar with it you can read more about it at&lt;br&gt;
&lt;a class="reference external" href="https://github.com/pyhandle/hpy/"&gt;HPy&lt;/a&gt;.&lt;br&gt;
&lt;br&gt;
A lot of attention was devoted to the Big HPy Design Discussion which&lt;br&gt;
took up two full mornings. So much was decided that this will likely&lt;br&gt;
get its own detailed write-up, but bigger topics included:&lt;br&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;the HPy GetAttr, SetAttr, GetItem and SetItem methods,&lt;/li&gt;
&lt;li&gt;HPy_FromVoidP and HPy_AsVoidP for passing HPy handles to C functions&lt;br&gt;
that pass void* pointers to callbacks,&lt;/li&gt;
&lt;li&gt;avoiding having va_args as part of the ABI,&lt;/li&gt;
&lt;li&gt;exception handling,&lt;/li&gt;
&lt;li&gt;support for creating custom types.&lt;/li&gt;
&lt;/ul&gt;
Quite a few things got worked on too:&lt;br&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;implemented support for writing methods that take keyword arguments with&lt;br&gt;
HPy_METH_KEYWORDS,&lt;/li&gt;
&lt;li&gt;implemented HPy_GetAttr, HPy_SetAttr, HPy_GetItem, and HPy_SetItem,&lt;/li&gt;
&lt;li&gt;started implementing support for adding custom types,&lt;/li&gt;
&lt;li&gt;started implementing dumping JSON objects in ultrajson-hpy,&lt;/li&gt;
&lt;li&gt;refactored the PyPy GIL to improve the interaction between HPy and&lt;br&gt;
PyPy's cpyext,&lt;/li&gt;
&lt;li&gt;experimented with adding HPy support to rust-cpython.&lt;/li&gt;
&lt;/ul&gt;
And there was some discussion of the next steps of the HPy initiative&lt;br&gt;
including writing documentation, setting up websites and funding, and&lt;br&gt;
possibly organising another HPy gathering later in the year.&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;
PyPy&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Georges gave a presentation on the Heptapod topic and branch workflows&lt;br&gt;
and showed everyone how to use hg-evolve.&lt;/li&gt;
&lt;li&gt;Work was done on improving the PyPy CI buildbot post the move to&lt;br&gt;
heptapod, including a light-weight pre-merge CI and restricting&lt;br&gt;
when the full CI is run to only branch commits.&lt;/li&gt;
&lt;li&gt;A lot of work was done improving the -D tests. &lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2&gt;
Miscellaneous&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Armin demoed VRSketch and NaN Industries in VR, including an implementation&lt;br&gt;
of the Game of Life within NaN Industries!&lt;/li&gt;
&lt;li&gt;Skiing!&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2&gt;
Aftermath&lt;/h2&gt;
Immediately after the sprint large parts of Europe and the world were&lt;br&gt;
hit by the COVID-19 epidemic. It was good to spend time together before&lt;br&gt;
travelling ceased to be a sensible idea and many gatherings were cancelled.&lt;br&gt;
&lt;br&gt;
Keep safe out there everyone.&lt;br&gt;
&lt;br&gt;
The HPy &amp;amp; PyPy Team &amp;amp; Friends&lt;br&gt;
&lt;br&gt;
&lt;i&gt;In joke for those who attended the sprint: Please don't replace this blog post&lt;br&gt;
with its Swedish translation (or indeed a translation to any other language :).&lt;/i&gt;</description><category>cpyext</category><category>CPython</category><category>GraalPython</category><category>Heptapod</category><category>hpy</category><category>pypy</category><category>pypy3</category><guid>https://www.pypy.org/posts/2020/03/leysin-2020-sprint-report-764567777353955897.html</guid><pubDate>Tue, 17 Mar 2020 21:57:00 GMT</pubDate></item><item><title>NO_TITLE</title><link>https://www.pypy.org/posts/2017/10/cape-of-good-hope-for-pypy-hello-from-3656631725712879033.html</link><dc:creator>The PyPy Team</dc:creator><description>&lt;h1 class="title"&gt;
&lt;span style="font-size: small;"&gt;
(Cape of)&lt;/span&gt;&lt;span style="font-size: x-small;"&gt; &lt;/span&gt;Good Hope for PyPy&lt;/h1&gt;
&lt;div&gt;
&lt;br&gt;&lt;/div&gt;
Hello from the other side of the world (for most of you)!&lt;br&gt;
&lt;br&gt;
With the excuse of coming to &lt;a class="reference external" href="https://za.pycon.org/"&gt;PyCon ZA&lt;/a&gt; during the last two weeks Armin,
Ronan, Antonio and sometimes Maciek had a very nice and productive sprint in
Cape Town, as pictures show :). We would like to say a big thank you to
Kiwi.com, which sponsored part of the travel costs via its awesome &lt;a class="reference external" href="https://www.kiwi.com/sourcelift/"&gt;Sourcelift&lt;/a&gt;
program to help Open Source projects.&lt;br&gt;
&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td style="text-align: center;"&gt;&lt;a href="https://3.bp.blogspot.com/-9YVNucPN1wE/WeaWmTUFB-I/AAAAAAAABMQ/HeVMqS-ya2IYJuk0iZZODlULqpKaf5XcgCLcBGAs/s1600/DSC_2418.JPG" style="margin-left: auto; margin-right: auto;"&gt;&lt;img border="0" height="225" src="https://3.bp.blogspot.com/-9YVNucPN1wE/WeaWmTUFB-I/AAAAAAAABMQ/HeVMqS-ya2IYJuk0iZZODlULqpKaf5XcgCLcBGAs/s400/DSC_2418.JPG" width="400"&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;Armin, Anto and Ronan at Cape Point&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;br&gt;
Armin, Ronan and Anto spent most of the time hacking at cpyext, our CPython
C-API compatibility layer: during the last years, the focus was to make it
working and compatible with CPython, in order to run existing libraries such
as numpy and pandas. However, we never paid too much attention to performance,
so the net result is that with the latest released version of PyPy, C
extensions generally work but their speed ranges from "slow" to "horribly
slow".&lt;br&gt;
&lt;br&gt;
For example, these very simple &lt;a class="reference external" href="https://github.com/antocuni/cpyext-benchmarks"&gt;microbenchmarks&lt;/a&gt; measure the speed of
calling (empty) C functions, i.e. the time you spend to "cross the border"
between RPython and C.  &lt;i&gt;(Note: this includes the time spent doing the loop in regular Python code.)&lt;/i&gt; These are the results on CPython, on PyPy 5.8, and on
our newest in-progress version:&lt;br&gt;
&lt;br&gt;
&lt;pre class="literal-block"&gt;$ python bench.py     # CPython
noargs      : 0.41 secs
onearg(None): 0.44 secs
onearg(i)   : 0.44 secs
varargs     : 0.58 secs
&lt;/pre&gt;
&lt;div&gt;
&lt;br&gt;&lt;/div&gt;
&lt;pre class="literal-block"&gt;$ pypy-5.8 bench.py   # PyPy 5.8
noargs      : 1.01 secs
onearg(None): 1.31 secs
onearg(i)   : 2.57 secs
varargs     : 2.79 secs
&lt;/pre&gt;
&lt;div&gt;
&lt;br&gt;&lt;/div&gt;
&lt;pre class="literal-block"&gt;$ pypy bench.py       # cpyext-refactor-methodobject branch
noargs      : 0.17 secs
onearg(None): 0.21 secs
onearg(i)   : 0.22 secs
varargs     : 0.47 secs
&lt;/pre&gt;
&lt;div&gt;
&lt;br&gt;&lt;/div&gt;
&lt;pre class="literal-block"&gt;&lt;/pre&gt;
&lt;pre class="literal-block"&gt;&lt;/pre&gt;
So yes: before the sprint, we were ~2-6x slower than CPython. Now, we are
&lt;strong&gt;faster&lt;/strong&gt; than it!
To reach this result, we did various improvements, such as:
&lt;br&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;teach the JIT how to look (a bit) inside the cpyext module;&lt;/li&gt;
&lt;li&gt;write specialized code for calling &lt;tt class="docutils literal"&gt;METH_NOARGS&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;METH_O&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;METH_VARARGS&lt;/tt&gt; functions; previously, we always used a very general and
slow logic;&lt;/li&gt;
&lt;li&gt;implement freelists to allocate the cpyext versions of &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;tuple&lt;/tt&gt; objects, as CPython does;&lt;/li&gt;
&lt;li&gt;the &lt;a class="reference external" href="https://bitbucket.org/pypy/pypy/commits/branch/cpyext-avoid-roundtrip"&gt;cpyext-avoid-roundtrip&lt;/a&gt; branch: crossing the RPython/C border is
slowish, but the real problem was (and still is for many cases) we often
cross it many times for no good reason. So, depending on the actual API
call, you might end up in the C land, which calls back into the RPython
land, which goes to C, etc. etc. (ad libitum).&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
The branch tries to fix such nonsense: so far, we fixed only some cases, which
are enough to speed up the benchmarks shown above.  But most importantly, we
now have a clear path and an actual plan to improve cpyext more and
more. Ideally, we would like to reach a point in which cpyext-intensive
programs run at worst at the same speed of CPython.&lt;br&gt;
&lt;br&gt;
The other big topic of the sprint was Armin and Maciej doing a lot of work on the
&lt;a class="reference external" href="https://bitbucket.org/pypy/pypy/commits/branch/unicode-utf8"&gt;unicode-utf8&lt;/a&gt; branch: the goal of the branch is to always use UTF-8 as the
internal representation of unicode strings. The advantages are various:
&lt;br&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;decoding a UTF-8 stream is super fast, as you just need to check that the
stream is valid;&lt;/li&gt;
&lt;li&gt;encoding to UTF-8 is almost a no-op;&lt;/li&gt;
&lt;li&gt;UTF-8 is always more compact representation than the currently
used UCS-4. It's also almost always more compact than CPython 3.5 latin1/UCS2/UCS4 combo;&lt;/li&gt;
&lt;li&gt;smaller representation means everything becomes quite a bit faster due to lower cache pressure.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
Before you ask: yes, this branch contains special logic to ensure that random
access of single unicode chars is still O(1), as it is on both CPython and the
current PyPy.&lt;br&gt;
We also plan to improve the speed of decoding even more by using modern processor features, like SSE and AVX. Preliminary results show that decoding can be done 100x faster than the current setup.
&lt;br&gt;
&lt;br&gt;
In summary, this was a long and profitable sprint, in which we achieved lots
of interesting results. However, what we liked even more was the privilege of
doing &lt;a class="reference external" href="https://bitbucket.org/pypy/pypy/commits/a4307fb5912e"&gt;commits&lt;/a&gt; from awesome places such as the top of Table Mountain:&lt;br&gt;
&lt;br&gt;
&lt;blockquote class="twitter-tweet"&gt;
&lt;div dir="ltr" lang="en"&gt;
Our sprint venue today &lt;a href="https://twitter.com/hashtag/pypy?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#pypy&lt;/a&gt; &lt;a href="https://t.co/o38IfTYmAV"&gt;pic.twitter.com/o38IfTYmAV&lt;/a&gt;&lt;/div&gt;
— Ronan Lamy (@ronanlamy) &lt;a href="https://twitter.com/ronanlamy/status/915575026107240449?ref_src=twsrc%5Etfw"&gt;4 ottobre 2017&lt;/a&gt;&lt;/blockquote&gt;


&lt;br&gt;
&lt;table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: left; margin-right: 1em; text-align: left;"&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td style="text-align: center;"&gt;&lt;a href="https://bytebucket.org/pypy/extradoc/raw/extradoc/sprintinfo/cape-town-2017/2017-10-04-155524.jpg" style="margin-left: auto; margin-right: auto;"&gt;&lt;img border="0" height="360" src="https://bytebucket.org/pypy/extradoc/raw/extradoc/sprintinfo/cape-town-2017/2017-10-04-155524.jpg" width="640"&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td class="tr-caption" style="text-align: center;"&gt;The panorama we looked at instead of staring at cpyext code&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</description><category>cpyext</category><category>sprint</category><category>unicode</category><guid>https://www.pypy.org/posts/2017/10/cape-of-good-hope-for-pypy-hello-from-3656631725712879033.html</guid><pubDate>Wed, 18 Oct 2017 13:31:00 GMT</pubDate></item><item><title>Using CPython extension modules with PyPy natively, or: PyPy can load .pyd files with CPyExt!</title><link>https://www.pypy.org/posts/2010/04/using-cpython-extension-modules-with-5864754772659599217.html</link><dc:creator>The PyPy Team</dc:creator><description>&lt;p&gt;PyPy is now able to load
and run CPython extension modules (i.e. .pyd and .so files) natively by using the new CPyExt
subsystem.
Unlike the solution presented in &lt;a class="reference external" href="https://morepypy.blogspot.com/2009/11/using-cpython-extension-modules-with.html"&gt;another blog post&lt;/a&gt; (where extension modules like
numpy etc. were run on CPython and proxied through TCP), this solution does not require
a running CPython anymore. We do not achieve full binary compatiblity
yet (like Ironclad), but recompiling the extension is generally enough.&lt;/p&gt;
&lt;p&gt;The only prerequisite is that the necessary functions of the C API of CPython are already
implemented in PyPy. If you are a user or an author of a module and miss certain functions
in PyPy, we invite you to implement them. Up until now, a lot of people (including a lot of
new committers) have stepped up and implemented a few functions to get their favorite module
running. See the end of this post for a list of names.&lt;/p&gt;
&lt;p&gt;Regarding speed, we tried the following: even though there is a bit of overhead when running
these modules, we could run the regular expression engine of CPython (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_sre.so&lt;/span&gt;&lt;/tt&gt;) and execute
the spambayes benchmark of the Unladen Swallow benchmark suite (cf. &lt;a class="reference external" href="https://speed.pypy.org/"&gt;speed.pypy.org&lt;/a&gt;) and
experience a speedup:
It became &lt;em&gt;two times faster&lt;/em&gt; on pypy-c than with the built-in regular
expression engine of PyPy. From &lt;a href="https://en.wikipedia.org/wiki/Amdahl%27s_law"&gt;Amdahl's Law&lt;/a&gt; it follows that the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_sre.so&lt;/span&gt;&lt;/tt&gt; must run several
times faster than the built-in engine.&lt;/p&gt;
&lt;p&gt;Currently pursued modules include PIL and others. Distutils support is nearly ready.
If you would like to participate or want information on how to use this new feature, come and join
our IRC channel &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;#pypy&lt;/span&gt;&lt;/tt&gt; on &lt;a class="reference external" href="irc://irc.freenode.net/"&gt;freenode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Amaury Forgeot d'Arc and Alexander Schremmer&lt;/p&gt;
&lt;p&gt;Further CPyExt Contributors:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Alex Gaynor
&lt;/li&gt;&lt;li&gt;Benjamin Peterson
&lt;/li&gt;&lt;li&gt;Jean-Paul Calderone
&lt;/li&gt;&lt;li&gt;Maciej Fijalkowski
&lt;/li&gt;&lt;li&gt;Jan de Mooij
&lt;/li&gt;&lt;li&gt;Lucian Branescu Mihaila
&lt;/li&gt;&lt;li&gt;Andreas Stührk
&lt;/li&gt;&lt;li&gt;Zooko Wilcox-O Hearn&lt;/li&gt;&lt;/ul&gt;</description><category>cpyext</category><category>CPython</category><category>extension modules</category><category>speed</category><guid>https://www.pypy.org/posts/2010/04/using-cpython-extension-modules-with-5864754772659599217.html</guid><pubDate>Fri, 09 Apr 2010 22:56:00 GMT</pubDate></item></channel></rss>