<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts about speed)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/categories/speed.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Tue, 09 Mar 2021 08:48:52 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Using CPython extension modules with PyPy natively, or: PyPy can load .pyd files with CPyExt!</title><link>https://www.pypy.org/posts/2010/04/using-cpython-extension-modules-with-5864754772659599217.html</link><dc:creator>The PyPy Team</dc:creator><description>&lt;p&gt;PyPy is now able to load
and run CPython extension modules (i.e. .pyd and .so files) natively by using the new CPyExt
subsystem.
Unlike the solution presented in &lt;a class="reference external" href="https://morepypy.blogspot.com/2009/11/using-cpython-extension-modules-with.html"&gt;another blog post&lt;/a&gt; (where extension modules like
numpy etc. were run on CPython and proxied through TCP), this solution does not require
a running CPython anymore. We do not achieve full binary compatiblity
yet (like Ironclad), but recompiling the extension is generally enough.&lt;/p&gt;
&lt;p&gt;The only prerequisite is that the necessary functions of the C API of CPython are already
implemented in PyPy. If you are a user or an author of a module and miss certain functions
in PyPy, we invite you to implement them. Up until now, a lot of people (including a lot of
new committers) have stepped up and implemented a few functions to get their favorite module
running. See the end of this post for a list of names.&lt;/p&gt;
&lt;p&gt;Regarding speed, we tried the following: even though there is a bit of overhead when running
these modules, we could run the regular expression engine of CPython (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_sre.so&lt;/span&gt;&lt;/tt&gt;) and execute
the spambayes benchmark of the Unladen Swallow benchmark suite (cf. &lt;a class="reference external" href="https://speed.pypy.org/"&gt;speed.pypy.org&lt;/a&gt;) and
experience a speedup:
It became &lt;em&gt;two times faster&lt;/em&gt; on pypy-c than with the built-in regular
expression engine of PyPy. From &lt;a href="https://en.wikipedia.org/wiki/Amdahl%27s_law"&gt;Amdahl's Law&lt;/a&gt; it follows that the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;_sre.so&lt;/span&gt;&lt;/tt&gt; must run several
times faster than the built-in engine.&lt;/p&gt;
&lt;p&gt;Currently pursued modules include PIL and others. Distutils support is nearly ready.
If you would like to participate or want information on how to use this new feature, come and join
our IRC channel &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;#pypy&lt;/span&gt;&lt;/tt&gt; on &lt;a class="reference external" href="irc://irc.freenode.net/"&gt;freenode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Amaury Forgeot d'Arc and Alexander Schremmer&lt;/p&gt;
&lt;p&gt;Further CPyExt Contributors:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Alex Gaynor
&lt;/li&gt;&lt;li&gt;Benjamin Peterson
&lt;/li&gt;&lt;li&gt;Jean-Paul Calderone
&lt;/li&gt;&lt;li&gt;Maciej Fijalkowski
&lt;/li&gt;&lt;li&gt;Jan de Mooij
&lt;/li&gt;&lt;li&gt;Lucian Branescu Mihaila
&lt;/li&gt;&lt;li&gt;Andreas Stührk
&lt;/li&gt;&lt;li&gt;Zooko Wilcox-O Hearn&lt;/li&gt;&lt;/ul&gt;</description><category>cpyext</category><category>CPython</category><category>extension modules</category><category>speed</category><guid>https://www.pypy.org/posts/2010/04/using-cpython-extension-modules-with-5864754772659599217.html</guid><pubDate>Fri, 09 Apr 2010 22:56:00 GMT</pubDate></item><item><title>PyPy gets a new compiler</title><link>https://www.pypy.org/posts/2009/08/pypy-gets-new-compiler_25-6401910947439531107.html</link><dc:creator>The PyPy Team</dc:creator><description>&lt;p&gt;Today, I merged the parser-compiler branch, which I have been working on over the summer. It contained a total rewrite of both PyPy's Python parser and AST compiler. PyPy's old parser was (in)famous internally for being complicated and slow (with many algorithmic complexities greater than O(n)). The new parser is a simple as &lt;a href="https://codespeak.net/viewvc/pypy/trunk/pypy/interpreter/pyparser/parser.py?view=markup"&gt;I could make it&lt;/a&gt; LL(1) parser like CPython (though it doesn't share the hacks of CPython's parser).&lt;/p&gt;

&lt;p&gt;The new compiler is based on the &lt;a href="https://doc.python.org/3.1/library/ast"&gt;Abstract Syntax Trees (AST) that CPython 2.5 introduced&lt;/a&gt; instead of PyPy's old AST based on the &lt;a href="https://doc.python.org/library/compiler"&gt;compiler package's&lt;/a&gt;. This means that Python code running on PyPy will be able to use the same _ast interface as CPython. PyPy's _ast implementation supports AST features that CPython 2.6 added, including &lt;a href="https://pythonic.pocoo.org/2008/3/29/ast-compilation-from-python"&gt;compiling modified AST to bytecode and executing it&lt;/a&gt;. In this rewrite, some more obscure compiler features were added, too. For example, jumps in bytecode can now be greater than 65535 bytes! (That's like an if statement with 7000 lines of code in the body.)&lt;/p&gt;

&lt;p&gt;While the PyPy translation toolchain still has many obscure details and hacks, this merge completes the process of making the actual Python interpreter very clean. Hopefully, this will make adding new features much easier and make PyPy less frustrating to maintain as well as providing application level code with an improved AST interface!&lt;/p&gt;</description><category>compiler</category><category>parser</category><category>speed</category><guid>https://www.pypy.org/posts/2009/08/pypy-gets-new-compiler_25-6401910947439531107.html</guid><pubDate>Tue, 25 Aug 2009 16:05:00 GMT</pubDate></item><item><title>Roadmap for JIT</title><link>https://www.pypy.org/posts/2009/04/roadmap-for-jit-377358891902851723.html</link><dc:creator>The PyPy Team</dc:creator><description>&lt;p&gt;Hello.
&lt;/p&gt;
&lt;p&gt;
First a disclaimer. This post is more about plans for future than current
status. We usually try to write about things that we have done, because
it's much much easier to promise things than to actually make it happen,
but I think it's important enough to have some sort of roadmap.
&lt;/p&gt;
&lt;p&gt;
In recent months we came to the point where the 5th generation of
JIT prototype was working as &lt;a href="https://morepypy.blogspot.com/2009/03/good-news-everyone.html"&gt;nice&lt;/a&gt;
or even a bit nicer than 1st one back in 2007. Someone might ask "so why
did you spend all this time without going forward?". And indeed, we spend
a lot of time moving sideways, but as posted, we also spent a lot of time
doing &lt;a href="https://morepypy.blogspot.com/2009/04/beta-for-110-released.html"&gt;some other things&lt;/a&gt;, which are important as well.
The main advantage of current JIT incarnation is much much simpler than
the first one. Even I can comprehend it, which is much of an improvement :-)
&lt;/p&gt;
&lt;p&gt;
So, the prototype is working and gives very nice speedups in range of 20-30x
over CPython. We're pretty confident this prototype will work and will
produce fast python interpreter eventually. So we decided that now we'll
work towards changing prototype into something stable and solid. This
might sound easy, but in fact it's not. Having stable assembler backend
and optimizations that keep semantics is not as easy as it might sound.
&lt;/p&gt;
&lt;p&gt;
The current roadmap, as I see it, looks like as following:
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; Provide a JIT that does not speedup things, but produce assembler without
  optimizations turned on, that is correct and able to run CPython's library
  tests on a nightly basis.
&lt;/li&gt;
&lt;li&gt;
 Introduce simple optimizations, that should make above JIT a bit faster than
  CPython. With optimizations disabled JIT is producing incredibly dumb
  assembler, which is slower than correspoding C code, even with removal
  of interpretation overhead (which is not very surprising).
&lt;/li&gt;
&lt;li&gt;
 Backport optimizations from JIT prototype, one by one, keeping an eye
  on how they perform and making sure they don't break anything.
&lt;/li&gt;
&lt;li&gt;
 Create new optimizations, like speeding up attribute access.
&lt;/li&gt;
&lt;li&gt;
 Profit.
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
This way, we can hopefully provide a working JIT, which gives fast python
interpreter, which is a bit harder than just a nice prototype.
&lt;/p&gt;
&lt;p&gt;
Tell us what you think about this plan.
&lt;/p&gt;
Cheers,&lt;br&gt;
fijal &amp;amp; others.</description><category>jit</category><category>pypy</category><category>roadmap</category><category>speed</category><guid>https://www.pypy.org/posts/2009/04/roadmap-for-jit-377358891902851723.html</guid><pubDate>Tue, 21 Apr 2009 19:38:00 GMT</pubDate></item></channel></rss>