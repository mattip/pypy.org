<!DOCTYPE html>
<html prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Controlling the Tracing of an Interpreter With Hints, Part 1: Controlling the Extent of Tracing | PyPy</title>
<link href="../../../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../../rss.xml">
<link rel="canonical" href="https://www.pypy.org/posts/2011/03/controlling-tracing-of-interpreter-with-871085470935630424.html">
<link rel="icon" href="../../../favicon2.ico" sizes="16x16">
<link rel="icon" href="../../../favicon32x32.ico" sizes="32x32">
<!--[if lt IE 9]><script src="../../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<meta name="author" content="The PyPy Team">
<link rel="prev" href="bay-area-2011-tour-summary-9117372109664978472.html" title="Bay Area 2011 Tour Summary" type="text/html">
<link rel="next" href="controlling-tracing-of-interpreter-with_15-3281215865169782921.html" title="Controlling the Tracing of an Interpreter With Hints, Part 2: Controlling Optimization" type="text/html">
<meta property="og:site_name" content="PyPy">
<meta property="og:title" content="Controlling the Tracing of an Interpreter With Hints, Part 1: Controll">
<meta property="og:url" content="https://www.pypy.org/posts/2011/03/controlling-tracing-of-interpreter-with-871085470935630424.html">
<meta property="og:description" content="The question I was asked most often during my recent US trip was how exactly
the hints work that interpreter authors can use to improve the execution speed
of the programs running on their interpreter">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2011-03-12T18:25:00Z">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../../../index.html">
                    <image id="toplogo" src="../../../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../../../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../../../compat.html">Compatibility</a> </li>  
                    <li> <a href="../../../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../../../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href="../../../blog">Index</a> </li>  
                    <li> <a href="../../../categories">Tags</a> </li>  
                    <li> <a href="../../../archive.html">Archive by year</a> </li>  
                    <li> <a href="../../../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://twitter.com/pypyproject">Twitter</a> </li>  
                    <li> <a href="https://quodlibet.duckdns.org/irc/pypy/latest.log.html#irc-end">IRC</a> </li>  
                    <li> <a href="../../../people.html">People</a> </li>  
                    <li> <a href="../../../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../../../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section></header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><div class="post">
          <header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Controlling the Tracing of an Interpreter With Hints, Part 1: Controlling the Extent of Tracing</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    The PyPy Team
            </span></p>
            <p class="dateline">
            <a href="#" rel="bookmark">
            <time class="published dt-published" datetime="2011-03-12T18:25:00Z" itemprop="datePublished" title="2011-03-12 18:25">2011-03-12 18:25</time></a>
            </p>
            <p class="commentline">  11 comments
</p>
                <p class="commentline">                <a href="controlling-tracing-of-interpreter-with-871085470935630424.html#utterances-thread">Comments</a>


            
        </p>
</div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
      <p>The question I was asked most often during my recent <a class="reference external" href="https://morepypy.blogspot.com/2011/03/us-trip-report-popl-microsoft-ibm.html">US trip</a> was how exactly
the hints work that interpreter authors can use to improve the execution speed
of the programs running on their interpreters. Since those hints are not really
documented all that well, I decided to write blog posts about them. This is the
first one.</p>
<div class="section" id="background">
<h2>Background</h2>
<p>First, let's recap some basics: PyPy's approach to implementing dynamic
languages is to write an interpreter for
the language in RPython. This interpreter can be translated to C and then
further to machine code. The interpreter consists of code in the form of a
large number of generated C functions and some data. Similarly, the user
program consists of functions in the language the interpreter executes.</p>
<p>As was explained in a <a class="reference external" href="https://morepypy.blogspot.com/2009/03/applying-tracing-jit-to-interpreter.html">blog post</a> and a <a class="reference external" href="https://codespeak.net/svn/pypy/extradoc/talk/icooolps2009/bolz-tracing-jit.pdf">paper</a> two years ago, PyPy's JIT is a
meta-tracer. Since we want to re-use our tracer for a variety of languages, we
don't trace the execution of the user program, but instead trace the execution
of the <em>interpreter</em> that is running the program. This means that the traces
don't contain the bytecodes of the language in question, but RPython-level
operations that the interpreter did to execute the program.</p>
<p>On the other hand, the loops that are traced by the tracer are the loops in the
user program. This means that the tracer stops tracing after one iteration of
the loop in the user function that is being considered. At this point, it can
have traced many iterations of the interpreter main loop.</p>
<p>Here's a diagram of this process:</p>

<a href="https://3.bp.blogspot.com/-YUYgnZkPta8/TXu694dW9bI/AAAAAAAAAPY/VOCWosHnXCM/s1600/trace-levels.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5583261735346173362" src="https://3.bp.blogspot.com/-YUYgnZkPta8/TXu694dW9bI/AAAAAAAAAPY/VOCWosHnXCM/s600/trace-levels.png" style="display: block; margin: 0px auto 10px; text-align: center; cursor: pointer; cursor: hand;"></a>

<p>On the left you see the levels of execution. The CPU executes the binary of
PyPy's Python interpreter, which consists of RPython functions that have been
compiled first to C, then to machine code. Some of these functions contain
loops, others don't. The interpreter runs a Python program written by a
programmer (the user). If the tracer is used, it traces operations on the level
of the interpreter. However, the extent of the trace is determined by the loops
in the user program.</p>
</div>
<div class="section" id="how-far-should-tracing-go">
<h2>How Far Should Tracing Go</h2>
<p>When the tracer encounters a function call at the interpreter level, e.g. the
interpreter main loop calling a helper function, it can do one of two things:</p>
<ol class="arabic simple">
<li>it can trace into the helper function, effectively inlining it into the trace.</li>
<li>it can not trace into the function and instead record a call to that function
as an operation in the trace. Such a call operation in the trace is sometimes
called <em>residual call</em>.</li>
</ol>
<p>As a default, the tracer will try to trace into the helper because that will
give more information to the optimizer, allowing it to do a better job. This is
particularly important for the allocation removal optimization, because if a
freshly allocated object is passed as an argument to a residual call, its
allocation cannot be optimized away.</p>
<p>There is a problem however if the helper function itself contains a loop. The
tracer records the linear sequence of operations that are being executed. Thus
when it encounters a loop on the interpreter level it records all the
operations of every iteration of the loop itself, with the net effect of
unrolling it. The only places where the tracer stops and tries to close the
trace is in the main loop of the interpreter. When the tracer encounters the
main loop, it also checks whether the original user loop has been closed, and
thus whether it can stop tracing.</p>
<p>For most helper functions in the interpreter that contain loops, fully
unrolling does not make sense. If a loop is unrolled, the trace is specific to
the number of iteration that was seen during tracing. If the trace is later
executed with a different number of iterations, the trace will be left via a
guard failure, which is inefficient. Therefore the default behaviour of the
tracer is to never trace into a function on the interpreter level that contains
a loop, but to trace into all non-looping helper functions.</p>
<p>This default behaviour is essentially a heuristic, but one that usually makes
sense. We want to produce just enough traces to make the resulting code
efficient, but not more. Therefore we trace as much as possible (everything by
default) except the functions which loops where tracing would produce code that
is less general than it could be.</p>
<p>As an example for a helper with a loop, take string concatenation. It loops over
the characters of both arguments and copies them over into the result string. It
does not make sense to unroll the loops in this function. If we do that,
the resulting trace can only be used for strings of the length that was seen
during tracing. In practise, the string lengths are usually different each run,
meaning that the trace with unrolling is not run to completion in most cases.</p>
</div>
<div class="section" id="influencing-the-default-behaviour">
<h2>Influencing the Default Behaviour</h2>
<p>Sometimes the default behaviour is not actually what is wanted. This is
something the interpreter author has to decide, usually by looking at the traces
that are produced and deciding that they should be improved. There are two ways
in which the default is wrong:</p>
<ul class="simple">
<li>
<strong>false negatives:</strong> if a helper function that <strong>does</strong> contain a loop should
be traced into, unrolling the loop.</li>
<li>
<strong>false positives:</strong> if a helper function that <strong>does not</strong> contain a loop is
inlined into the trace, but the interpreter author decides that this is not
helpful.</li>
</ul>
<p>If the interpreter author finds false negatives or false positives, she can fix
that by applying a hint to the tracer. These hints take the form of function
decorators (which both live in the <tt class="docutils literal">pypy.rlib.jit</tt> module). In the next two
subsections I will describe these two function decorators and their use.</p>
<div class="section" id="unrolling-functions-with-loops">
<h3>Unrolling Functions With Loops</h3>
<p>The first decorator, used to fix false negatives, is the <tt class="docutils literal">unroll_safe</tt>
decorator. It is used to tell the tracer to always trace into a function that
has a loop, effectively unrolling the loop. This decorator should be used only
if the loop in the helper function is expected to always run for the same number
of iterations. This sounds like a strong restriction, in practise this is less
severe: The number of iterations needs to only be the same <em>in the context where
the helper functions is traced from</em>.</p>
<p>It is easiest to understand this condition via an example. Let's look at the
<tt class="docutils literal">BUILD_TUPLE</tt> bytecode in Python. It takes one argument, the length <tt class="docutils literal">n</tt> of
the tuple being built. The bytecode pops <tt class="docutils literal">n</tt> arguments from the stack, turns
them into a tuple and pushes that tuple on the stack. Thus the function that
implements <tt class="docutils literal">BUILD_TUPLE</tt> in PyPy's Python interpreter calls a helper
<tt class="docutils literal">popvalues</tt> which pops <tt class="docutils literal">n</tt> values from the stack and returns them in a list.
This helper is implemented with a loop and would thus not be traced into by
default.  The loop in the helper can run for very different numbers of
iterations, because it is used in a variety of places. However, for every
concrete <tt class="docutils literal">BUILD_TUPLE</tt> bytecode, the argument will be constant. Therefore it
is safe (and even necessary) to annotate <tt class="docutils literal">popvalues</tt> with the <tt class="docutils literal">unroll_safe</tt>
decorator.</p>
<p>A different example is the implementation of the <tt class="docutils literal">isinstance</tt> builtin. It is
used to check whether an object <tt class="docutils literal">a</tt> is an instance of a class <tt class="docutils literal">B</tt> like
this: <tt class="docutils literal">isinstance(a, B)</tt>. The second argument of the function can also be a
tuple of classes to check whether an object is an instance of one of a number of
classes: <tt class="docutils literal">isinstance(a, (A, B, C, D))</tt>. To implement this second case, the
implementation of <tt class="docutils literal">isinstance</tt> contains a loop iterating over the elements of
the tuple. The number of loop iterations can vary, but is usually fixed for each
individual call site which typically just lists a few classes in the source
code. Therefore it is also safe to annotate the implementation of <tt class="docutils literal">isinstance</tt>
with the <tt class="docutils literal">unroll_safe</tt> decorator.</p>
</div>
<div class="section" id="preventing-the-tracing-of-functions">
<h3>Preventing the Tracing of Functions</h3>
<p>The second decorator <tt class="docutils literal">dont_look_inside</tt> is used to fix false positives. It
tells the JIT to never trace into the decorated function and just always produce
a residual call instead. This decorator is in many ways less important than the
unrolling one (except for a special situation that I will describe in a
follow-up post). It is used if tracing into a function is not expected to yield
any speed benefits, because the optimizer will not be able to improve it much.
This is often the case if the called helper function does not contain any
"dynamic" behaviour. In such a situation it is better to just leave the function
call in the trace, because that produces less code.</p>
<p>An example would be the import mechanism in Python. It's very unlikely that any
performance improvement can be had by turning part of it into assembler.
Therefore we hide it from the tracer by annotating them with
<tt class="docutils literal">dont_look_inside</tt>.</p>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion</h2>
<p>In this post we discussed two hints that can be used to control precisely which
parts of the interpreter should be meta-traced. If these hints are used
carefully, this can go a long way to making the interpreter produce traces that
contain exactly the interesting part of the execution, and will contain calls to
the functions that can not be optimized by tracing techniques.</p>
<p>In the <a href="https://morepypy.blogspot.com/2011/03/controlling-tracing-of-interpreter-with_15.html">next part of this series</a> I will discuss a different set of hints that can
be used to strongly optimize traces.</p>
</div>
      </div>
      <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="bay-area-2011-tour-summary-9117372109664978472.html" rel="prev" title="Bay Area 2011 Tour Summary">Previous post</a>
            </li>
            <li class="next">
                <a href="controlling-tracing-of-interpreter-with_15-3281215865169782921.html" rel="next" title="Controlling the Tracing of an Interpreter With Hints, Part 2: Controlling Optimization">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
                <div class="comment-level comment-level-1">
      <div class="comment comment-8326070612955967399">
        <div class="comment-header">
          <a name="comment-8326070612955967399"></a>
            <span class="author">Victor</span> wrote on <span class="date">2011-03-12 21:28</span>:
        </div>
        <div class="comment-content">
          <p>Would it be possible (i.e. is the code amenable) to programmatically randomly sprinkle these decorators around and compare effects on speed (or on measurable trace quality)?<br><br>It would make JIT generation a bit more meta :)</p>
        </div>
      </div>
      <div class="comment comment-4363661425795501150">
        <div class="comment-header">
          <a name="comment-4363661425795501150"></a>
            <span class="author">Gaëtan de Menten</span> wrote on <span class="date">2011-03-13 10:42</span>:
        </div>
        <div class="comment-content">
          <p>Thanks for the very interesting post!<br><br>Sorry if the following questions are naive, but you post makes me wonder if not tracing at all the functions which contain loops with a varying number of iteration means that no optimization is possible at all for those loops? Also, wouldn't it be possible to detect there is a loop and produce a special kind of trace in that case which do not duplicate the body of the loop? I guess that if it was possible and useful, you'd have done it, so I guess the real question is: why doesn't this work?</p>
        </div>
      </div>
      <div class="comment comment-1727117587162670099">
        <div class="comment-header">
          <a name="comment-1727117587162670099"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-14 09:54</span>:
        </div>
        <div class="comment-content">
          <p>@Victor: yes, there are probably ways to do place some of the hints more automatically. However, you will always have to look at the traces and think about how to improve them, so we chose the pragmatic path and didn't do anything magic.</p>
        </div>
      </div>
      <div class="comment comment-1689979069960067279">
        <div class="comment-header">
          <a name="comment-1689979069960067279"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-14 10:02</span>:
        </div>
        <div class="comment-content">
          <p>@Gaëtan: those are excellent questions!<br><br>Yes, functions in the interpreter with loops that we do not trace are not optimized at all. For most of these functions this is not a problem, e.g. string concatenation does not have much optimization potential anyway. However, there are some functions with loops (like the implementation of the map builtin) that would benefit from tracing, and we don't have a good general solution for that yet.<br><br>One of the ideas for solutions are indeed to try to start new traces in the interpreter functions with loops. We did not get around to playing with this yet, as there are not so many cases in the Python interpreter where this leads to a huge benefit.</p>
        </div>
      </div>
      <div class="comment comment-965537567419824717">
        <div class="comment-header">
          <a name="comment-965537567419824717"></a>
            <span class="author">Gaëtan de Menten</span> wrote on <span class="date">2011-03-14 13:50</span>:
        </div>
        <div class="comment-content">
          <p>I'm puzzled now. I fail to see why those loops "do not have much optimization potential". I can understand that it's hard to optimize them because of the trace problem but I thought they would benefit from optimization like any other code (eg avoiding boxing/unboxing temporary variables), especially since they are within a loop, hence any gain will be multiplied by the number of iterations.</p>
        </div>
      </div>
      <div class="comment comment-2464670344307874252">
        <div class="comment-header">
          <a name="comment-2464670344307874252"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-14 14:01</span>:
        </div>
        <div class="comment-content">
          <p>@Gaëtan:<br>is it possible that you are mixing up the two levels involved? The post talked only about functions in the interpreter, not about the functions in pure Python that a user of the interpreter might write. To clarify:<br><br>- All loops on the application level, i.e. in the program the user wrote, are traceable and will be traced if they are executed often enough.<br><br>- Some loops in the interpreter itself are not. Most of these loops do not do any boxing/unboxing, so they won't benefit from optimization. For some of the loops that would benefit we added some manual hacks to trace them anyway, e.g. for the implementation of "map". Some others still need to be improved, e.g. any, all, zip, ...</p>
        </div>
      </div>
      <div class="comment comment-4933343857625838892">
        <div class="comment-header">
          <a name="comment-4933343857625838892"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2011-03-15 14:52</span>:
        </div>
        <div class="comment-content">
          <p>Carl, thanks for the post. The information is very helpful.<br><br>While I understand special casing to overwrite the default tracing/not-tracing rules can help performance, I wonder how well are the default heuristics performing. Do you have any bulk part estimation of the performance loss by turning off special casing? And how many hints (related to whether to trace or unroll) do you have to introduce to PyPy?</p>
        </div>
      </div>
      <div class="comment comment-781314709244498950">
        <div class="comment-header">
          <a name="comment-781314709244498950"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-15 16:00</span>:
        </div>
        <div class="comment-content">
          <p>Hi Peng,<br><br>Thanks :-). No, I didn't really do benchmarks yet, plan to do so in the future (these blog posts will turn into a paper soonish).<br><br>There are about 20-30 unroll_safe hints and equally many dont_look_inside hints. Some of them are really important, ie the speed would be abysmal without them. Most of them are really in the bytecode dispatch area, they are cases that e.g. Jython would not have, because in Jython the Python-to-Java compiler takes care of them.</p>
        </div>
      </div>
      <div class="comment comment-8391486534209894437">
        <div class="comment-header">
          <a name="comment-8391486534209894437"></a>
            <span class="author">Gaëtan de Menten</span> wrote on <span class="date">2011-03-16 10:45</span>:
        </div>
        <div class="comment-content">
          <p>No, I wasn't confusing the two levels involved (if pypy wasn't optimizing variable-length loops in userlevel code, it wouldn't optimize much I guess). <br><br>My point was more theoretical: I guess that, in theory, those loops would benefit from optimizations like any other part of the interpreter. Your answer leads me to believe that *in practice* this isn't an issue because there are either not that many of them in the interpreter and/or they are not in speed critical parts and most of those that are important speed-wise have been taken care of manually in some way or another.</p>
        </div>
      </div>
      <div class="comment comment-8364446666492635032">
        <div class="comment-header">
          <a name="comment-8364446666492635032"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2011-03-16 12:15</span>:
        </div>
        <div class="comment-content">
          <p>@Gaëtan: yes, that's a good interpretation. At some point we might still think about a more general solution for this problem, to get the remaining rare cases fixed, but for now we have a lot of the common ones covered.</p>
        </div>
      </div>
      <div class="comment comment-5640768429293734401">
        <div class="comment-header">
          <a name="comment-5640768429293734401"></a>
            <span class="author">Matty</span> wrote on <span class="date">2017-06-07 12:50</span>:
        </div>
        <div class="comment-content">
          <p>@Gaëtan<br>Untraceable Interpreter-level loops don't need to be optimized by the jit because they are agressively optimized by the C compiler (remeber that rpython is translated to C)</p>
        </div>
      </div>
         </div>

          </section>
</div>
    <div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2020/12/mac-meets-arm64-940822335619099039.html" class="listtitle">Mac meets Arm64</a>
      </li>
      <li>
        <a href="/posts/2020/11/pypy-733-triple-release-python-37-36-3446596804408262749.html" class="listtitle">PyPy 7.3.3 triple release: python 3.7, 3.6, and 2.7</a>
      </li>
      <li>
        <a href="/posts/2020/09/pypy-732-triple-release-python-27-36-3980901335490872787.html" class="listtitle">PyPy 7.3.2 triple release: python 2.7, 3.6, and 3.7</a>
      </li>
      <li>
        <a href="/posts/2020/08/pypy-is-on-open-collective-5673322428814364737.html" class="listtitle">PyPy is on Open Collective</a>
      </li>
      <li>
        <a href="/posts/2020/08/a-new-chapter-for-pypy-8388322709667328389.html" class="listtitle">A new chapter for PyPy</a>
      </li>
      <li>
        <a href="/posts/2020/04/pypy-731-released-6266451647387657480.html" class="listtitle">PyPy 7.3.1 released</a>
      </li>
      <li>
        <a href="/posts/2020/03/leysin-2020-sprint-report-764567777353955897.html" class="listtitle">Leysin 2020 Sprint Report</a>
      </li>
      <li>
        <a href="/posts/2020/02/pypy-and-cffi-have-moved-to-heptapod-5791595152472747032.html" class="listtitle">PyPy and CFFI have moved to Heptapod</a>
      </li>
      <li>
        <a href="/posts/2020/01/leysin-winter-sprint-2020-feb-28-march-6349761524797409012.html" class="listtitle">Leysin Winter sprint 2020: Feb 29 - March 8th</a>
      </li>
      <li>
        <a href="/posts/2019/12/pypy-730-released-3614026620096963655.html" class="listtitle">PyPy 7.3.0 released</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (1)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (3)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (2)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (18)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (1)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (47)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releasepypy.html">releasepypy</a> (1)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (3)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
          </ul>
        </div>    </div>
</article></main><footer id="footer"><p>
</p>
<div class="myfooter">
  <div>
    <img src="../../../images/pypy-logo-nav-grey.png" alt="PyPy Logo">
</div>
  <div class="logotext">
     Contents © 2021 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
    Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a> 
  </div>
  <div style="margin-left: auto">
  <a href="rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../../../assets/js/styles.js"></script></footer>
</div>
</body>
</html>
