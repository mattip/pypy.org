<!DOCTYPE html>
<html prefix="
        og: http://ogp.me/ns# article: http://ogp.me/ns/article#
    " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Faster, more memory efficient and more ordered dictionaries on PyPy | PyPy</title>
<link href="../../../assets/css/rst_base.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/nikola_rst.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/code.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="../../../assets/css/styles.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../../../rss.xml">
<link rel="canonical" href="https://www.pypy.org/posts/2015/01/faster-more-memory-efficient-and-more-4096950404745375390.html">
<link rel="icon" href="../../../favicon2.ico" sizes="16x16">
<link rel="icon" href="../../../favicon32x32.ico" sizes="32x32">
<!--[if lt IE 9]><script src="../../../assets/js/html5shiv-printshiv.min.js"></script><![endif]--><link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
<meta name="author" content="The PyPy Team">
<link rel="prev" href="leysin-winter-sprint-20-28th-february-2590212640945547308.html" title="Leysin Winter Sprint (20-28th February 2015)" type="text/html">
<link rel="next" href="../02/pypy-250-released-247160062953533060.html" title="PyPy 2.5.0 released" type="text/html">
<meta property="og:site_name" content="PyPy">
<meta property="og:title" content="Faster, more memory efficient and more ordered dictionaries on PyPy">
<meta property="og:url" content="https://www.pypy.org/posts/2015/01/faster-more-memory-efficient-and-more-4096950404745375390.html">
<meta property="og:description" content="Hello everyone!
As of today, we merged the latest branch that brings better dictionaries to PyPy by default. The work is based on an idea by Raymond Hettinger on python-dev, with prior work done notab">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2015-01-22T11:31:00Z">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
             <header id="header"><!-- Adapted from https://www.taniarascia.com/responsive-dropdown-navigation-bar --><section class="navigation"><div class="nav-container">
            <div class="brand">
                <a href="../../../index.html">
                    <image id="toplogo" src="../../../images/pypy-logo.svg" width="75px;" alt="PyPy/"></image></a>
            </div>
            <nav><ul class="nav-list">
<li> 
                <a href="#!">Features</a>
                <ul class="nav-dropdown">
<li> <a href="../../../features.html">What is PyPy?</a> </li>  
                    <li> <a href="../../../compat.html">Compatibility</a> </li>  
                    <li> <a href="../../../performance.html">Performance</a> </li>  
                </ul>
</li>
          <li> <a href="../../../download.html">Download</a> </li>  
          <li> <a href="http://doc.pypy.org">Dev Docs</a> </li>  
            <li> 
                <a href="#!">Blog</a>
                <ul class="nav-dropdown">
<li> <a href="../../../blog">Index</a> </li>  
                    <li> <a href="../../../categories">Tags</a> </li>  
                    <li> <a href="../../../archive.html">Archive by year</a> </li>  
                    <li> <a href="../../../rss.xml">RSS feed</a> </li>  
                    <li> <a href="https://morepypy.blogspot.com/">Old site</a> </li>  
                </ul>
</li>
            <li> 
                <a href="#!">About</a>
                <ul class="nav-dropdown">
<li> <a href="https://twitter.com/pypyproject">Twitter</a> </li>  
                    <li> <a href="https://quodlibet.duckdns.org/irc/pypy/latest.log.html#irc-end">IRC</a> </li>  
                    <li> <a href="../../../people.html">People</a> </li>  
                    <li> <a href="../../../howtohelp.html">How To Help?</a> </li>  
                    <li> <a href="../../../contact.html">Contact</a> </li>  
                </ul>
</li>

                </ul></nav><div class="nav-mobile">
                <a id="nav-toggle" href="#!"> <span></span></a>
            </div>
        </div>
    </section></header><main id="content"><article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><div class="post">
          <header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Faster, more memory efficient and more ordered dictionaries on PyPy</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    The PyPy Team
            </span></p>
            <p class="dateline">
            <a href="#" rel="bookmark">
            <time class="published dt-published" datetime="2015-01-22T11:31:00Z" itemprop="datePublished" title="2015-01-22 11:31">2015-01-22 11:31</time></a>
            </p>
            <p class="commentline">  18 comments
</p>
                <p class="commentline">                <a href="faster-more-memory-efficient-and-more-4096950404745375390.html#utterances-thread">Comments</a>


            
        </p>
</div>
        
    </header><div class="e-content entry-content" itemprop="articleBody text">
      <div dir="ltr" style="text-align: left;">
<p>Hello everyone!</p>
<p>As of today, we merged the latest branch that brings better dictionaries to PyPy by default. The work is based on an idea by Raymond Hettinger on <a class="reference external" href="https://mail.python.org/pipermail/python-dev/2012-December/123028.html">python-dev</a>, with prior work done notably in Java.  It was done by Maciej Fijałkowski and Armin Rigo, with Laurence Tratt recently prodding us to finish it.  (Earlier work going in a similar direction include Alex Gaynor's work on ordered dicts in Topaz, which was also used in the Hippy VM.  Each of these pieces of work is itself based on the original dict implementation in RPython, whose origins fade in the Subversion prehistory of PyPy.)  Coincidentally, a very similar idea has been implemented in Zend PHP very recently. <a class="reference external" href="https://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">Zend implementation description</a>.</p>
<p>This post covers the basics of design and implementation as well as some basic benchmarks.</p>
</div>
<div class="section" id="dictionaries-are-now-ordered">
<h3>Dictionaries are now ordered!</h3>
<p>One surprising part is that the new design, besides being more
memory efficient, is ordered by design: it preserves the
insertion order.  This is not forbidden by the Python language, which allows any order.  It makes the <tt class="docutils literal">collections.OrderedDict</tt> subclass much faster than before: it is now a thin subclass of <tt class="docutils literal">dict</tt>.  Obviously, we recommend that any portable Python program continues to use <tt class="docutils literal">OrderedDict</tt> when ordering is important.  Note that a non-portable program might rely on more: for example, a <tt class="docutils literal">**keywords</tt> argument now receives the keywords in the same order as the one in which they were given in the call.  (Whether such a thing might be called a language design change or not is a bit borderline.)  The point is that Python programs that work on CPython or previous versions of PyPy should continue to work on PyPy.</p>
<p>There is one exception, though.  The iterators of the <tt class="docutils literal">OrderedDict</tt> subclass are now working just like the ones of the <tt class="docutils literal">dict</tt> builtin: they will raise <tt class="docutils literal">RuntimeError</tt> when iterating if the dictionary was modified.  In the CPython design, the class <tt class="docutils literal">OrderedDict</tt> explicitly doesn't worry about that, and instead you get some result that might range from correct to incorrect to crashes (i.e. random Python exceptions).</p>
</div>
<div class="section" id="original-pypy-dictionary-design">
<h3>Original PyPy dictionary design</h3>
<p>Originally, PyPy dictionaries, as well as CPython dictionaries
are implemented as follows (simplified view):</p>
<pre class="literal-block">
struct dict {
   long num_items;
   dict_entry* items;   /* pointer to array */
}

struct dict_entry {
   long hash;
   PyObject* key;
   PyObject* value;
}
</pre>
<p>Where items is a sparse array, with 1/3 to 1/2 of the items being NULL.
The average space occupied by a dictionary is <tt class="docutils literal">3 * WORD * 12/7</tt> plus some small constant (the smallest dict has 8 entries, which is
<tt class="docutils literal">8 * 3 * WORD + 2 * WORD = 26 WORDs</tt>).</p>
</div>
<div class="section" id="new-pypy-dictionary-design">
<h3>New PyPy dictionary design</h3>
<p>The new PyPy dictionary is split in two arrays:</p>
<pre class="literal-block">
struct dict {
    long num_items;
    variable_int *sparse_array;
    dict_entry* compact_array;
}

struct dict_entry {
    long hash;
    PyObject *key;
    PyObject *value;
}
</pre>
<p>Here, <tt class="docutils literal">compact_array</tt> stores all the items in order of insertion, while <tt class="docutils literal">sparse_array</tt> is a 1/2 to 2/3 full array of integers. The integers themselves are of the smallest size necessary for indexing the <tt class="docutils literal">compact_array</tt>. So if <tt class="docutils literal">compact_array</tt> has less than 256 items, then <tt class="docutils literal">sparse_array</tt> will be made of bytes; if less than 2^16, it'll be two-byte integers; and so on.</p>
<p>This design saves quite a bit of memory. For example, on 64bit systems we can, but almost never, use indexing of more than 4 billion elements; and for small dicts, the extra <tt class="docutils literal">sparse_array</tt> takes very little space.  For example a 100 element dict, would be on average for the original design on 64bit: 100 * 12/7 * WORD * 3 =~ 4100 bytes, while on new design it's 100 * 12/7 + 3 * WORD * 100 =~ 2600 bytes, quite a significant saving.</p>
</div>
<div class="section" id="gc-friendliness">
<h3>GC friendliness</h3>
<p>The obvious benefit of having more compact dictionaries is an increased cache friendliness. In modern CPUs cache misses are much more costly than doing additional simple work, like having an additional level of (in-cache) indirection. Additionally, there is a GC benefit coming from it. When doing a minor collection, the GC has to visit all the GC fields in old objects that can point to young objects. In the case of large arrays, this can prove problematic since the array grows and with each minor collection we need to visit more and more GC pointers. In order to avoid it, large arrays in PyPy employ a technique called "card marking" where the GC only visits "cards" or subsets of arrays that were modified between collections. The problem with dictionaries was that by design modifications in a dictionary occur randomly, hence a lot of cards used to get invalidated. In the new design, however, new items are typically appended to the <tt class="docutils literal">compact_array</tt>, hence invalidate much fewer cards --- which improves GC performance.  (The new <tt class="docutils literal">sparse_array</tt> is an array of integers, so it does not suffer from the same problems.)</p>
</div>
<div class="section" id="deletion">
<h3>Deletion</h3>
<p>Deleting entries from dictionaries is not very common, but important in a few use cases.  To preserve order, when we delete an entry, we mark the entry as removed but don't otherwise shuffle the remaining entries.  If we repeat this operation often enough, there will be a lot of removed entries in the (originally compact) array.  At this point, we need to do a "packing" operation, which moves all live entries to the start of the array (and then reindexes the sparse array, as the positions changed).  This works well, but there are use cases where previously no reindexing was ever needed, so it makes these cases a bit slower (for example when repeatedly adding and removing keys in equal number).</p>
</div>
<div class="section" id="benchmarks">
<h3>Benchmarks</h3>
<p>The PyPy speed benchmarks show mostly small effect, <a class="reference external" href="https://speed.pypy.org/changes/?tre=10&amp;rev=75419%3Ac52fc1774518&amp;exe=1&amp;env=1">see changes</a>. The microbenchmarks that we did show large improvements on large and very large dictionaries (particularly, building dictionaries of at least a couple 100s of items is now twice faster) and break-even on small ones (between 20% slower and 20% faster depending very much on the usage patterns and sizes of dictionaries). The new dictionaries enable various optimization possibilities which we're going to explore in the near future.</p>
<p>Cheers,<br>
fijal, arigo and the PyPy team</p>
</div>
<br>
</div>
      <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="leysin-winter-sprint-20-28th-february-2590212640945547308.html" rel="prev" title="Leysin Winter Sprint (20-28th February 2015)">Previous post</a>
            </li>
            <li class="next">
                <a href="../02/pypy-250-released-247160062953533060.html" rel="next" title="PyPy 2.5.0 released">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
                <div class="comment-level comment-level-1">
      <div class="comment comment-1891836419877302725">
        <div class="comment-header">
          <a name="comment-1891836419877302725"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2015-01-22 16:26</span>:
        </div>
        <div class="comment-content">
          <p>This is outstanding work, PyPy team. Keep on keeping on!</p>
        </div>
      </div>
      <div class="comment comment-4320921419516509607">
        <div class="comment-header">
          <a name="comment-4320921419516509607"></a>
            <span class="author">Wilfred Hughes</span> wrote on <span class="date">2015-01-22 16:41</span>:
        </div>
        <div class="comment-content">
          <p>Fantastic!<br><br>https://pypy.org/performance.html states that large dicts are a weakness of pypy -- is still the case overall, or is this work sufficient to favour pypy over cpython for large dict work in general?</p>
        </div>
      </div>
      <div class="comment comment-4373673796938302900">
        <div class="comment-header">
          <a name="comment-4373673796938302900"></a>
            <span class="author">John M. Camara</span> wrote on <span class="date">2015-01-23 01:35</span>:
        </div>
        <div class="comment-content">
          <p>Wilfred - With the ordered dict changes that bullet item is no longer true.</p>
        </div>
      </div>
      <div class="comment comment-7498804428762440826">
        <div class="comment-header">
          <a name="comment-7498804428762440826"></a>
            <span class="author">EM Lazzarin</span> wrote on <span class="date">2015-01-23 23:20</span>:
        </div>
        <div class="comment-content">
          <p>Awesome work and thanks. Pypy would be ahead of the game if PEP 468 were accepted.</p>
        </div>
      </div>
      <div class="comment comment-1120475895514743974">
        <div class="comment-header">
          <a name="comment-1120475895514743974"></a>
            <span class="author">JSZ</span> wrote on <span class="date">2015-01-24 19:04</span>:
        </div>
        <div class="comment-content">
          <p>How is deleting an element implemented? It sounds like it would take O(n) work to remove an element from the middle of the compact array.</p>
        </div>
      </div>
      <div class="comment comment-7846831096687909796">
        <div class="comment-header">
          <a name="comment-7846831096687909796"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2015-01-25 06:58</span>:
        </div>
        <div class="comment-content">
          <p>JSZ: the array gets holes.  If a lot of items are deleted it can no longer be called "compact", but if it becomes too sparse it is recompacted and rehashed.</p>
        </div>
      </div>
      <div class="comment comment-5258266563019598092">
        <div class="comment-header">
          <a name="comment-5258266563019598092"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2015-01-28 11:09</span>:
        </div>
        <div class="comment-content">
          <p>There are lots of things to like about this approach!<br><br>Did you find any problems with cache misses? With linear probing, the keys are accessed sequentially (cache friendly), but with this method the keys are accessed in random order.</p>
        </div>
      </div>
      <div class="comment comment-6933695346652786031">
        <div class="comment-header">
          <a name="comment-6933695346652786031"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2015-01-28 11:13</span>:
        </div>
        <div class="comment-content">
          <p>@Anonymous: The old approach didn't use linear probing either, so in that regard nothing changed.</p>
        </div>
      </div>
      <div class="comment comment-3853981107061015751">
        <div class="comment-header">
          <a name="comment-3853981107061015751"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2015-01-28 11:45</span>:
        </div>
        <div class="comment-content">
          <p>@carl - ah I see, thats interesting.<br><br>Well then, what about storing the hashes with the indices?<br>* Another chunk of memory saved. Only the lowest N bits need be stored that way instead of the full 64 bits. (Big assumption that rehashing on bit size change is ok)<br><br>* The nice thing is that the dense part (cache miss!) need only be accessed if the hash matches.<br><br>I think if I was doing this, I'd skip 8 bit indices and have 16 bit minimum so rehashing would be very rare.</p>
        </div>
      </div>
      <div class="comment comment-4932481408082287637">
        <div class="comment-header">
          <a name="comment-4932481408082287637"></a>
            <span class="author">Carl Friedrich Bolz-Tereick</span> wrote on <span class="date">2015-01-28 12:04</span>:
        </div>
        <div class="comment-content">
          <p>two problems with that:<br><br>- since the hash functions can be written in python, recomputing a hash from a key is potentially expensive<br><br>- why would you want to throw away bits from the hash? comparing the full hashes as a first check to see whether equality has a chance to succeed is very useful. the equality function can again be written in python, so is potentially very slow.</p>
        </div>
      </div>
      <div class="comment comment-7801112224845080111">
        <div class="comment-header">
          <a name="comment-7801112224845080111"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2015-01-28 16:03</span>:
        </div>
        <div class="comment-content">
          <p>@Anonymous: about starting at 16-bit instead of 8-bit: it doesn't give any benefit, because rehashing is needed anyway to grow the sparse table.  As long as its size is at most 256, then there is no point in storing 16-bit numbers instead of 8-bit numbers.  In theory we could store N-bit numbers for the optimal value of N (= 4, 6, 8, 10...) and pay only the cost of additional complexity for individual reads and writes, not for rehashing.</p>
        </div>
      </div>
      <div class="comment comment-4399141062784458775">
        <div class="comment-header">
          <a name="comment-4399141062784458775"></a>
            <span class="author">Anonymous</span> wrote on <span class="date">2015-01-28 21:39</span>:
        </div>
        <div class="comment-content">
          <p>Ah indeed. I am thinking of implementing this in C++ which has coloured my thoughts somewhat. In my case, key equality checks are for the most part cheap. Thus the size/compute tradeoffs may be a bit different.<br><br>Thanks for your thoughts.</p>
        </div>
      </div>
      <div class="comment comment-7325361872796082065">
        <div class="comment-header">
          <a name="comment-7325361872796082065"></a>
            <span class="author">Dustin Boswell</span> wrote on <span class="date">2015-02-04 23:05</span>:
        </div>
        <div class="comment-content">
          <p>Just curious, was there no slowdown from adding this extra level of indirection? For the case of accessing a random key from a cold dictionary, won't the lookup incur 2 cache misses now (one on each array), compared to just 1 for the original design?</p>
        </div>
      </div>
      <div class="comment comment-3754072720581770556">
        <div class="comment-header">
          <a name="comment-3754072720581770556"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2015-02-05 15:11</span>:
        </div>
        <div class="comment-content">
          <p>@Durtin: there are certainly slow-downs in some cases.  If the dictionary is cold, then indeed there is one extra cache miss. It seems to be quickly compensated, though, by the fact that if then you do a few more accesses to the same dict, you are likely to get less cache misses, simply because of the more compact layout.  Also, the index array is often single bytes, so it can be fully in the cache very quickly.</p>
        </div>
      </div>
      <div class="comment comment-4403399074384655146">
        <div class="comment-header">
          <a name="comment-4403399074384655146"></a>
            <span class="author">Alhabshi3k</span> wrote on <span class="date">2015-02-11 08:44</span>:
        </div>
        <div class="comment-content">
          <p>Thank you for improving pypy performance and features.  Your project and method  is promising in improvement weakness aspect of dynamic languages.  At the same time, pypy should provide an simplicity of Python rather than diversity , where diversity is the reality but simplicity is the case. <br><br>Making dictionaries ordered by default is part of  simplicity; in this effort I wish integrating the features of "defaultdict" as method and properties of the the default basic dictionary.  <br><br>similar case , integrating "deque" features (as well ,method and properties) as part of pypy list datatype. <br><br>Usually I wonder why python team didn't integrate the features  of these "collections"   ( as they say "High-performance container datatypes" ) within original python basic datatype, as we all know , everything in Python is an Object.  and I don't think it is a pythonic  way to do things in diversity.<br><br>Anyhow , keep on your development and team spirit.</p>
        </div>
      </div>
      <div class="comment comment-3570302623197012495">
        <div class="comment-header">
          <a name="comment-3570302623197012495"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2015-02-11 09:07</span>:
        </div>
        <div class="comment-content">
          <p>@Alhabshi3k: indeed, you're right in that "defaultdict" could be replaced with an alternate constructor of the regular dicts.  I'm not sure why it is not so.  For deques, it is maybe a question of performance, but particularly of underlying C-level memory layout: CPython can't easily add appendleft() and popleft() to regular lists while still keeping the same C API, notably PyList_GET_ITEM() and PySequence_Fast_ITEMS() --- though that is debatable.<br><br>We could support that in PyPy, but that is arguably more of a language change than just making dicts ordered with no new user-visible API.</p>
        </div>
      </div>
      <div class="comment comment-9210320443384874332">
        <div class="comment-header">
          <a name="comment-9210320443384874332"></a>
            <span class="author">Unknown</span> wrote on <span class="date">2018-02-06 20:31</span>:
        </div>
        <div class="comment-content">
          <p>You say for 100 elements, the new design's compact array uses 3 * WORD * 100 memory, right? So no extra capacity whatsoever? Then what do you do when I insert another element? Allocate a new array with 3 * WORD * 101 memory and copy all data there (and write the new element at the end)? That would be highly inefficient. So I don't believe you're honest about the memory usage.</p>
        </div>
      </div>
      <div class="comment comment-2562121759679124360">
        <div class="comment-header">
          <a name="comment-2562121759679124360"></a>
            <span class="author">Armin Rigo</span> wrote on <span class="date">2018-02-06 21:08</span>:
        </div>
        <div class="comment-content">
          <p>The actual items are stored in a list which, like a list object, is slightly overallocated.  Maybe the text in the blog post missed that and it should add a "k": the average is "100 * 12/7 + 3 * WORD * 100 * k" for an average value of k around 17/16.  That's around 2700 instead of 2600.</p>
        </div>
      </div>
         </div>

          </section>
</div>
    <div class="sidebar">
<div>
  <h2>
    The PyPy blogposts
  </h2>
  <div>
    Create a guest post via a PR to the <a href="https://github.com/pypy/pypy.org">source repo</a>
  </div>
</div>
    <div id="global-recent-posts">
    <h2>
      Recent Posts
    </h2>
    <ul class="post-list">
      <li>
        <a href="/posts/2020/12/mac-meets-arm64-940822335619099039.html" class="listtitle">Mac meets Arm64</a>
      </li>
      <li>
        <a href="/posts/2020/11/pypy-733-triple-release-python-37-36-3446596804408262749.html" class="listtitle">PyPy 7.3.3 triple release: python 3.7, 3.6, and 2.7</a>
      </li>
      <li>
        <a href="/posts/2020/09/pypy-732-triple-release-python-27-36-3980901335490872787.html" class="listtitle">PyPy 7.3.2 triple release: python 2.7, 3.6, and 3.7</a>
      </li>
      <li>
        <a href="/posts/2020/08/pypy-is-on-open-collective-5673322428814364737.html" class="listtitle">PyPy is on Open Collective</a>
      </li>
      <li>
        <a href="/posts/2020/08/a-new-chapter-for-pypy-8388322709667328389.html" class="listtitle">A new chapter for PyPy</a>
      </li>
      <li>
        <a href="/posts/2020/04/pypy-731-released-6266451647387657480.html" class="listtitle">PyPy 7.3.1 released</a>
      </li>
      <li>
        <a href="/posts/2020/03/leysin-2020-sprint-report-764567777353955897.html" class="listtitle">Leysin 2020 Sprint Report</a>
      </li>
      <li>
        <a href="/posts/2020/02/pypy-and-cffi-have-moved-to-heptapod-5791595152472747032.html" class="listtitle">PyPy and CFFI have moved to Heptapod</a>
      </li>
      <li>
        <a href="/posts/2020/01/leysin-winter-sprint-2020-feb-28-march-6349761524797409012.html" class="listtitle">Leysin Winter sprint 2020: Feb 29 - March 8th</a>
      </li>
      <li>
        <a href="/posts/2019/12/pypy-730-released-3614026620096963655.html" class="listtitle">PyPy 7.3.0 released</a>
      </li>
    </ul>
  </div>

          <div id="global-archive-list">
          <h2>
            Archives
          </h2>
          <ul class="archive-level archive-level-1">
            <li><a class="reference" href="/2007/">2007</a> (19)
            </li>
            <li><a class="reference" href="/2008/">2008</a> (62)
            </li>
            <li><a class="reference" href="/2009/">2009</a> (38)
            </li>
            <li><a class="reference" href="/2010/">2010</a> (44)
            </li>
            <li><a class="reference" href="/2011/">2011</a> (43)
            </li>
            <li><a class="reference" href="/2012/">2012</a> (44)
            </li>
            <li><a class="reference" href="/2013/">2013</a> (46)
            </li>
            <li><a class="reference" href="/2014/">2014</a> (22)
            </li>
            <li><a class="reference" href="/2015/">2015</a> (20)
            </li>
            <li><a class="reference" href="/2016/">2016</a> (20)
            </li>
            <li><a class="reference" href="/2017/">2017</a> (13)
            </li>
            <li><a class="reference" href="/2018/">2018</a> (12)
            </li>
            <li><a class="reference" href="/2019/">2019</a> (12)
            </li>
            <li><a class="reference" href="/2020/">2020</a> (9)
            </li>
          </ul>
        </div>


          <div id="global-tag-list">
          <h2>
            Tags
          </h2>
          <ul>
            <li><a class="reference" href="/categories/arm.html">arm</a> (1)</li>
            <li><a class="reference" href="/categories/cli.html">cli</a> (1)</li>
            <li><a class="reference" href="/categories/compiler.html">compiler</a> (1)</li>
            <li><a class="reference" href="/categories/cpyext.html">cpyext</a> (3)</li>
            <li><a class="reference" href="/categories/cpython.html">CPython</a> (3)</li>
            <li><a class="reference" href="/categories/ep2008.html">ep2008</a> (1)</li>
            <li><a class="reference" href="/categories/extension-modules.html">extension modules</a> (2)</li>
            <li><a class="reference" href="/categories/graalpython.html">GraalPython</a> (1)</li>
            <li><a class="reference" href="/categories/hpy.html">hpy</a> (1)</li>
            <li><a class="reference" href="/categories/heptapod.html">Heptapod</a> (1)</li>
            <li><a class="reference" href="/categories/jit.html">jit</a> (18)</li>
            <li><a class="reference" href="/categories/jython.html">jython</a> (1)</li>
            <li><a class="reference" href="/categories/kcachegrind.html">kcachegrind</a> (1)</li>
            <li><a class="reference" href="/categories/numpy.html">numpy</a> (24)</li>
            <li><a class="reference" href="/categories/parser.html">parser</a> (1)</li>
            <li><a class="reference" href="/categories/profiling.html">profiling</a> (1)</li>
            <li><a class="reference" href="/categories/pypy.html">pypy</a> (6)</li>
            <li><a class="reference" href="/categories/pypy3.html">pypy3</a> (16)</li>
            <li><a class="reference" href="/categories/pyqt4.html">PyQt4</a> (1)</li>
            <li><a class="reference" href="/categories/release.html">release</a> (47)</li>
            <li><a class="reference" href="/categories/releasecffi.html">releasecffi</a> (3)</li>
            <li><a class="reference" href="/categories/releasepypy.html">releasepypy</a> (1)</li>
            <li><a class="reference" href="/categories/releaserevdb.html">releaserevdb</a> (1)</li>
            <li><a class="reference" href="/categories/releasestm.html">releasestm</a> (1)</li>
            <li><a class="reference" href="/categories/revdb.html">revdb</a> (1)</li>
            <li><a class="reference" href="/categories/roadmap.html">roadmap</a> (1)</li>
            <li><a class="reference" href="/categories/rpyc.html">RPyC</a> (1)</li>
            <li><a class="reference" href="/categories/speed.html">speed</a> (3)</li>
            <li><a class="reference" href="/categories/sprint.html">sprint</a> (3)</li>
            <li><a class="reference" href="/categories/stm.html">stm</a> (14)</li>
            <li><a class="reference" href="/categories/sun.html">sun</a> (1)</li>
            <li><a class="reference" href="/categories/smalltalk.html">Smalltalk</a> (1)</li>
            <li><a class="reference" href="/categories/squeak.html">Squeak</a> (1)</li>
            <li><a class="reference" href="/categories/unicode.html">unicode</a> (1)</li>
            <li><a class="reference" href="/categories/valgrind.html">valgrind</a> (1)</li>
          </ul>
        </div>    </div>
</article></main><footer id="footer"><p>
</p>
<div class="myfooter">
  <div>
    <img src="../../../images/pypy-logo-nav-grey.png" alt="PyPy Logo">
</div>
  <div class="logotext">
     Contents © 2021 <a href="mailto:pypy-dev@pypy.org">The PyPy Team</a>
    Powered by <a href="https://getnikola.com" rel="nofollow">Nikola</a> 
  </div>
  <div style="margin-left: auto">
  <a href="rss.xml">RSS feed</a>
</div>

            
        

    </div>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js" crossorigin="anonymous"></script><script src="../../../assets/js/styles.js"></script></footer>
</div>
</body>
</html>
